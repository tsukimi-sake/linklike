<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>画像から矩形領域を切り取る</title>
  <style>
    #output-canvas {
      border: 1px solid #80c4f3;
      display: none;
    }

    #template-img {
      display: none;
    }

    #template-canvas {
      display: none;
    }

    #h1 {
      background: linear-gradient(to right, #80c4f3, #878ef8);
      color: white;
    }
  </style>
</head>

<body>
  <h1 id="h1">画像アップロードと矩形検出</h1>
  <img id="template-img" src="images/rank1.png">
  <canvas id="template-canvas"></canvas>

  <input type="file" id="input-file" accept="image/png, image/jpeg, image/jpg" multiple>
  
  <div id="progress-container" style="width: 300px; height: 20px; border: 1px solid #ccc; margin-top: 10px; display: none;">
    <div id="progress-bar" style="height: 100%; width: 0%; background-color: #80c4f3;"></div>
  </div>

  <canvas id="output-canvas"></canvas>
  <button id="download-button" disabled>ダウンロード</button>

  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://docs.opencv.org/4.10.0/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.1/dist/tesseract.min.js"></script>

  <script>
    cv.onRuntimeInitialized = function () {
      const minWidth = 450, minHeight = 60, maxWidth = 900, maxHeight = 270;
      const trimmingRatio_X = 0.251, trimmingRatio_Y = 0.254, trimmingRatio_Width = 0.162, trimmingRatio_Height = 0.540;
      const validImageTypes = ['image/png', 'image/jpeg', 'image/jpg'];

      var templateRank1Mat;
      var items = [];
      var cnt, error_cnt;
      var outputCanvas = $("#output-canvas")[0];
      var outputCtx = outputCanvas.getContext("2d");

      const WORKER_COUNT = 3;
      let tesseractWorkers = [], workerIndex = 0;

      const template_img = $('#template-img')[0];
      const canvas = $('#template-canvas')[0];
      const ctx = canvas.getContext("2d");
      template_img.crossOrigin = 'anonymous';

      template_img.onload = function () {
        canvas.width = template_img.width;
        canvas.height = template_img.height;
        ctx.drawImage(template_img, 0, 0);
        templateRank1Mat = cv.imread(canvas);
      };

      async function createWorkerPool(count) {
        const workers = [];
        for (let i = 0; i < count; i++) {
          const worker = Tesseract.createWorker();
          await worker.load();
          await worker.loadLanguage('eng');
          await worker.initialize('eng');
          workers.push(worker);
        }
        return workers;
      }

      async function extractTextWithWorker(mat) {
        let trimMat = mat.roi(new cv.Rect(
          Math.trunc(trimmingRatio_X * mat.cols),
          Math.trunc(trimmingRatio_Y * mat.rows),
          Math.trunc(trimmingRatio_Width * mat.cols),
          Math.trunc(trimmingRatio_Height * mat.rows)
        ));

        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        canvas.width = trimMat.cols;
        canvas.height = trimMat.rows;
        cv.imshow(canvas, trimMat);

        let imageData = canvas.toDataURL();

        let currentWorker = tesseractWorkers[workerIndex];
        workerIndex = (workerIndex + 1) % tesseractWorkers.length;

        let result = await currentWorker.recognize(imageData);
        const regex = /\b\d+\b/g;
        let matches = result.data.text.match(regex);
        return matches ? matches[0] : null;
      }

      async function processExtractText(mat, rects) {
        for (let index = 0; index < rects.length; index++) {
          const rect = rects[index];
          let mat_roi = mat.roi(expandRect(rect, mat, 3));
          let text = await extractTextWithWorker(mat_roi);

          if (text == null && templateRank1Mat) {
            const match = detectRank1WithTemplate(mat_roi, templateRank1Mat);
            if (match) text = "1";
            else error_cnt++;
          }

          items.push({ mat: mat_roi, index: cnt, text: text });
          cnt++;
        }
      }

      $("#input-file").on("change", async function (e) {
        const files = e.target.files;
        if (!files.length) return;

        $("#download-button").prop("disabled", true).hide();
        $("#progress-container").show();
        $("#progress-bar").css("width", "0%");

        init();
        tesseractWorkers = await createWorkerPool(WORKER_COUNT);
        workerIndex = 0;

        let completed = 0;
        const updateProgress = () => {
          completed++;
          const percent = Math.floor((completed / files.length) * 100);
          $("#progress-bar").css("width", `${percent}%`);
        };

        let filePromises = [];

        for (const file of files) {
          if (!validImageTypes.includes(file.type)) continue;

          const promise = new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = function (e) {
              let img = new Image();
              img.onload = async function () {
                let mat = cv.imread(img);
                let rects = detectRectangles(mat, 500, 500, 3000, 3000);

                if (rects.length > 0) {
                  mat = mat.roi(expandRect(rects[0], mat, -30));
                  rects = detectRectangles(mat, minWidth, minHeight, maxWidth, maxHeight);
                  await processExtractText(mat, rects);
                }
                updateProgress();
                resolve();
              };
              img.src = e.target.result;
            };
            reader.readAsDataURL(file);
          });

          filePromises.push(promise);
        }

        await Promise.all(filePromises);
        $("#progress-container").fadeOut();

        for (const worker of tesseractWorkers) {
          await worker.terminate();
        }
        tesseractWorkers = [];

        if (items.length > 0) {
          $("#download-button").prop("disabled", false).show();
        }
      });

      function expandRect(rect, mat, expanded_pixel) {
        let x = Math.max(0, rect.x - expanded_pixel);
        let y = Math.max(0, rect.y - expanded_pixel);
        let width = Math.min(mat.cols - x, rect.width + (expanded_pixel * 2));
        let height = Math.min(mat.rows - y, rect.height + (expanded_pixel * 2));
        return new cv.Rect(x, y, width, height);
      }

      function detectRectangles(mat, minWidth, minHeight, maxWidth, maxHeight) {
        let gray = new cv.Mat();
        cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
        let edges = new cv.Mat();
        cv.Canny(gray, edges, 300, 300);
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let rects = [];
        for (let i = 0; i < contours.size(); i++) {
          let contour = contours.get(i);
          let approx = new cv.Mat();
          cv.approxPolyDP(contour, approx, 0.05 * cv.arcLength(contour, true), true);
          if (approx.rows === 4 && cv.isContourConvex(approx)) {
            let rect = cv.boundingRect(approx);
            if (rect.width >= minWidth && rect.height >= minHeight && rect.width <= maxWidth && rect.height <= maxHeight) {
              rects.push(rect);
            }
          }
          approx.delete();
        }

        gray.delete();
        edges.delete();
        contours.delete();
        hierarchy.delete();

        return rects;
      }

      function detectRank1WithTemplate(mat, templateMat) {
        const result = new cv.Mat();
        const matchThreshold = 0.6;
        let foundMatch = false;

        cv.matchTemplate(mat, templateMat, result, cv.TM_CCOEFF_NORMED);
        let minMax = cv.minMaxLoc(result);
        if (minMax.maxVal > matchThreshold) {
          foundMatch = true;
        }

        result.delete();
        return foundMatch;
      }

      $("#download-button").on("click", async function () {
        let zip = new JSZip();
        let folder = zip.folder("cropped_images");
        let promises = [];

        items.forEach((item) => {
          let tmpCanvas = document.createElement("canvas");
          let tmpCtx = tmpCanvas.getContext("2d");
          tmpCanvas.width = item.mat.cols;
          tmpCanvas.height = item.mat.rows;
          cv.imshow(tmpCanvas, item.mat);
          let imgData = tmpCanvas.toDataURL("image/png");

          let promise = fetch(imgData)
            .then(res => res.blob())
            .then(blob => {
              const fileName = item.text ? `cropped_image_${item.text}.png` : `error.png`;
              folder.file(fileName, blob);
            });

          promises.push(promise);
        });

        Promise.all(promises).then(() => {
          zip.generateAsync({ type: "blob" }).then((content) => {
            let link = document.createElement("a");
            link.href = URL.createObjectURL(content);
            link.download = "cropped_images.zip";
            link.click();
          });
        });
      });

      function init() {
        items = [];
        cnt = 0;
        error_cnt = 0;
      }
    };
  </script>
</body>

</html>
